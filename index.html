<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tetris Mobile</title>

<style>
body {
  margin: 0;
  background: #111;
  color: white;
  font-family: sans-serif;
  touch-action: none;
}

.screen {
  display: none;
  height: 100vh;
  flex-direction: column;
}
.active { display: flex; }

canvas {
  background: black;
  border: 2px solid #555;
  width: 100%;
  max-height: 60vh;
}

button {
  padding: 14px;
  font-size: 18px;
  margin: 6px;
  border-radius: 10px;
  border: none;
  background: #333;
  color: white;
}

button:active {
  background: #555;
}

/* 메뉴 */
#menu {
  justify-content: center;
  align-items: center;
}

/* 게임 화면 */
#game {
  justify-content: space-between;
}

/* 터치 패드 */
.controls {
  height: 40vh;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  gap: 10px;
  padding: 10px;
}

.controls button {
  font-size: 24px;
}

.rotate {
  grid-column: 2;
}

.left {
  grid-column: 1;
  grid-row: 2;
}

.down {
  grid-column: 2;
  grid-row: 2;
}

.right {
  grid-column: 3;
  grid-row: 2;
}

/* 게임 오버 */
.overlay {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.7);
  display: none;
  justify-content: center;
  align-items: center;
}
.overlay.active { display: flex; }

.modal {
  background: #222;
  padding: 30px;
  border-radius: 10px;
  text-align: center;
}
</style>
</head>

<body>

<!-- 메뉴 -->
<div id="menu" class="screen active">
  <h1>테트리스</h1>
  <button onclick="startGame()">시작하기</button>
</div>

<!-- 게임 -->
<div id="game" class="screen">
  <canvas id="tetris" width="240" height="400"></canvas>

  <!-- 터치 컨트롤 -->
  <div class="controls">
    <button class="rotate">↑</button>
    <button class="left">←</button>
    <button class="down">↓</button>
    <button class="right">→</button>
  </div>

  <div id="gameOver" class="overlay">
    <div class="modal">
      <h2>Game Over</h2>
      <button onclick="restart()">다시 하기</button>
      <button onclick="backToMenu()">메인 화면</button>
    </div>
  </div>
</div>

<script>
/* ===== 화면 ===== */
const menu = document.getElementById('menu');
const gameScreen = document.getElementById('game');
const gameOverUI = document.getElementById('gameOver');

const show = s => {
  [menu, gameScreen].forEach(v => v.classList.remove('active'));
  s.classList.add('active');
};

const startGame = () => { resetGame(); show(gameScreen); };
const backToMenu = () => { gameOverUI.classList.remove('active'); show(menu); };
const restart = () => { gameOverUI.classList.remove('active'); resetGame(); };

/* ===== 테트리스 ===== */
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
ctx.scale(20,20);

const ROWS=20, COLS=12;
let arena, player, gameOver=false;
let dropInterval=700, dropCounter=0, lastTime=0;

const colors = [
  null,
  '#FFB3C6','#BDE0FE','#CDB4DB','#A0E7E5',
  '#B9FBC0','#FFD6A5','#FFC8DD','#FFFFFF'
];

function resetGame(){
  arena = Array.from({length:ROWS},()=>Array(COLS).fill(0));
  player = { pos:{x:5,y:0}, matrix:null };
  gameOver = false;
  spawn();
}

function spawn(){
  const p='ILJOTSZ';
  player.matrix = createPiece(p[Math.random()*7|0]);
  player.pos = {x:5,y:0};
  if (collide()) endGame();
}

function endGame(){
  gameOver = true;
  gameOverUI.classList.add('active');
}

function createPiece(t){
  if(t==='I')return[[1],[1],[1],[1]];
  if(t==='O')return[[2,2],[2,2]];
  if(t==='T')return[[0,3,0],[3,3,3]];
  if(t==='L')return[[0,4],[0,4],[4,4]];
  if(t==='J')return[[5,0],[5,0],[5,5]];
  if(t==='S')return[[0,6,6],[6,6,0]];
  if(t==='Z')return[[7,7,0],[0,7,7]];
}

function collide(){
  return player.matrix.some((r,y)=>
    r.some((v,x)=>v && arena[y+player.pos.y]?.[x+player.pos.x]!==0)
  );
}

function merge(){
  player.matrix.forEach((r,y)=>r.forEach((v,x)=>{
    if(v) arena[y+player.pos.y][x+player.pos.x]=v;
  }));
}

function clearLines(){
  for(let y=arena.length-1;y>=0;y--){
    if(arena[y].every(v=>v)){
      arena.splice(y,1);
      arena.unshift(Array(COLS).fill(0));
      y++;
    }
  }
}

function rotate(){
  const m = player.matrix;
  player.matrix = m[0].map((_,i)=>m.map(r=>r[i]).reverse());
  if (collide()) player.matrix = m;
}

function drop(){
  player.pos.y++;
  if (collide()){
    player.pos.y--;
    merge();
    clearLines();
    spawn();
  }
}

function draw(){
  ctx.fillStyle='#000';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  arena.forEach((r,y)=>r.forEach((v,x)=>{
    if(v){ ctx.fillStyle=colors[v]; ctx.fillRect(x,y,1,1); }
  }));
  player.matrix.forEach((r,y)=>r.forEach((v,x)=>{
    if(v){ ctx.fillStyle=colors[v]; ctx.fillRect(x+player.pos.x,y+player.pos.y,1,1); }
  }));
}

function update(t=0){
  const delta=t-lastTime;
  lastTime=t;
  if(!gameOver){
    dropCounter+=delta;
    if(dropCounter>dropInterval){ drop(); dropCounter=0; }
    draw();
  }
  requestAnimationFrame(update);
}

/* ===== 터치 컨트롤 ===== */
document.querySelector('.left').ontouchstart = ()=>{ player.pos.x--; if(collide()) player.pos.x++; };
document.querySelector('.right').ontouchstart = ()=>{ player.pos.x++; if(collide()) player.pos.x--; };
document.querySelector('.down').ontouchstart = ()=> drop();
document.querySelector('.rotate').ontouchstart = ()=> rotate();

resetGame();
update();
</script>
</body>
</html>
